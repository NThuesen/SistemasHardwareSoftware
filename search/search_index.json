{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sistemas Hardware-Software \u00b6 Bem vindo ao curso de Sistemas Hardware-Software 2025/1. Professor : Fabio Lubacheski (e-mail: fabioagl@insper.edu.br ) Ninja : Aulas \u00b6 SEG 15:45 - 17:45 (Lab \u00c1gil 2) QUI 15:45 - 17:45 (Lab \u00c1gil 2) Atendimento: QUI 14:00 - 15:30 (Lab \u00c1gil 1) Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamento: Avalia\u00e7\u00f5es Intermedi\u00e1ria (AI) e Final (AF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site Ver crit\u00e9rios de avalia\u00e7\u00e3o na aula 01 Para consultar informa\u00e7\u00f5es detalhadas sobre a disciplina acesse o Plano de Aula","title":"Home"},{"location":"#sistemas-hardware-software","text":"Bem vindo ao curso de Sistemas Hardware-Software 2025/1. Professor : Fabio Lubacheski (e-mail: fabioagl@insper.edu.br ) Ninja :","title":"Sistemas Hardware-Software"},{"location":"#aulas","text":"SEG 15:45 - 17:45 (Lab \u00c1gil 2) QUI 15:45 - 17:45 (Lab \u00c1gil 2) Atendimento: QUI 14:00 - 15:30 (Lab \u00c1gil 1)","title":"Aulas"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamento: Avalia\u00e7\u00f5es Intermedi\u00e1ria (AI) e Final (AF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site Ver crit\u00e9rios de avalia\u00e7\u00e3o na aula 01 Para consultar informa\u00e7\u00f5es detalhadas sobre a disciplina acesse o Plano de Aula","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Entregas de Atividades e Labs \u00b6 Data in\u00edcio Atividade/Lab Como entregar Prazo 03/02 Instala\u00e7\u00e3o Sem entrega, apenas instale o Ubuntu 22.04! 10/02 15:45 10/02 Atv01-inteiros Github (Lembre de Criar repo e Configurar webhook ) 19/02 23h59 Provas \u00b6 Multir\u00e3o C : final da primeira semana AI : Semana da Avalia\u00e7ao Intermedi\u00e1ria AF : Semana da Avalia\u00e7\u00e3o Final SUB : semana da SUB","title":"Entregas e Prazos"},{"location":"sobre/#entregas-de-atividades-e-labs","text":"Data in\u00edcio Atividade/Lab Como entregar Prazo 03/02 Instala\u00e7\u00e3o Sem entrega, apenas instale o Ubuntu 22.04! 10/02 15:45 10/02 Atv01-inteiros Github (Lembre de Criar repo e Configurar webhook ) 19/02 23h59","title":"Entregas de Atividades e Labs"},{"location":"sobre/#provas","text":"Multir\u00e3o C : final da primeira semana AI : Semana da Avalia\u00e7ao Intermedi\u00e1ria AF : Semana da Avalia\u00e7\u00e3o Final SUB : semana da SUB","title":"Provas"},{"location":"aulas/01-inteiros/","text":"01 - Inteiros na CPU \u00b6 Os exerc\u00edcios da aula de hoje est\u00e3o no execut\u00e1vel bases_e_sinais . Aula com atividade para entrega! Confira em Conte\u00fados no Blackboard como criar seu reposit\u00f3rio para entregas e configurar o webhook do servidor de testes. Assim que criar seu reposit\u00f3rio, a atividade 01 j\u00e1 estar\u00e1 dispon\u00edvel nele. Configure o webhook para conseguir realizar as entregas. Atividade 01: atv01 \u00b6 Tip Leia o README dispon\u00edvel na pasta atv\\01-inteiros do seu reposit\u00f3rio de entregas! Nesta atividade, \u00e9 esperado que voc\u00ea realize diversas convers\u00f5es entre bases. O que voc\u00ea precisa fazer \u00e9: 1. Rodar programa bases_e_sinais 2. Colocar sua solu\u00e7\u00e3o em solucao.txt 3. Verificar se tudo est\u00e1 ok rodando (a saida final do programa \u00e9 Exerc\u00edcio correto! ) Ent\u00e3o, quando o execut\u00e1vel bases_e_sinais for chamado com ./bases_e_sinais < solucao.txt o esperado \u00e9 que seja obitido na sa\u00edda o texto Exerc\u00edcio correto! . Assim, tudo est\u00e1 Ok e voc\u00ea pode fazer o release! Boa atividade! Tip O README dispon\u00edvel na pasta atv\\01-inteiros tamb\u00e9m indica como realizar a entrega !","title":"01 - Inteiros na CPU"},{"location":"aulas/01-inteiros/#01-inteiros-na-cpu","text":"Os exerc\u00edcios da aula de hoje est\u00e3o no execut\u00e1vel bases_e_sinais . Aula com atividade para entrega! Confira em Conte\u00fados no Blackboard como criar seu reposit\u00f3rio para entregas e configurar o webhook do servidor de testes. Assim que criar seu reposit\u00f3rio, a atividade 01 j\u00e1 estar\u00e1 dispon\u00edvel nele. Configure o webhook para conseguir realizar as entregas.","title":"01 - Inteiros na CPU"},{"location":"aulas/01-inteiros/#atividade-01-atv01","text":"Tip Leia o README dispon\u00edvel na pasta atv\\01-inteiros do seu reposit\u00f3rio de entregas! Nesta atividade, \u00e9 esperado que voc\u00ea realize diversas convers\u00f5es entre bases. O que voc\u00ea precisa fazer \u00e9: 1. Rodar programa bases_e_sinais 2. Colocar sua solu\u00e7\u00e3o em solucao.txt 3. Verificar se tudo est\u00e1 ok rodando (a saida final do programa \u00e9 Exerc\u00edcio correto! ) Ent\u00e3o, quando o execut\u00e1vel bases_e_sinais for chamado com ./bases_e_sinais < solucao.txt o esperado \u00e9 que seja obitido na sa\u00edda o texto Exerc\u00edcio correto! . Assim, tudo est\u00e1 Ok e voc\u00ea pode fazer o release! Boa atividade! Tip O README dispon\u00edvel na pasta atv\\01-inteiros tamb\u00e9m indica como realizar a entrega !","title":"Atividade 01: atv01"},{"location":"aulas/02-ram/","text":"02 - Representa\u00e7\u00e3o de dados em RAM \u00b6 Experimentos \u00b6 Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles, execute e analise suas sa\u00eddas. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Tente entender o que est\u00e1 acontecendo. Para compilar cada .c , utilize: $ gcc -Wall -pedantic experimento0.c -o e0 Exercise Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Representa\u00e7\u00e3o de struct em RAM \u00b6 A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Aten\u00e7\u00e3o! Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Vamos compilar?! Compile e execute parte1.c . Exercise Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Exercise A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Exercise Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Hora de conferir! Agora confira suas respostas no arquivo parte1.c . Examinando a execu\u00e7\u00e3o de programas usando gdb \u00b6 Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Dica! Para compilar um programa com suporte a debugging usamos a flag -g do gcc $ gcc -g -Wall -pedantic parte2.c -o parte2 Siga os passos para para carregar um programa usando o gdb : Lance o gdb e passe para ele seu programa: $ gdb ./parte2 Para sair, utilize: (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser acessada em: https://sourceware.org/gdb/onlinedocs/gdb/index.html#Top . Uma explica\u00e7\u00e3o detalhadas dos comandos do gdb pode ser encontrada nesse link: https://diveintosystems.org/book/C3-C_debug/gdb_commands.html . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Exercise Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Aten\u00e7\u00e3o, tarefa dupla! Para os pr\u00f3ximos exerc\u00edcios, compile o arquivo parte2.c com e sem debugging e repita cada exerc\u00edcio com ambas as vers\u00f5es do execut\u00e1vel. Exemplo de compila\u00e7\u00e3o: $ gcc -g -Wall -pedantic parte2.c -o parte2_debug $ gcc -Wall -pedantic parte2.c -o parte2_semdebug Exercise O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Execute-o e veja o que acontece. Exercise Use info para mostrar as fun\u00e7\u00f5es e vari\u00e1veis globais que existem em parte2 . Lembre de fazer tanto na vers\u00e3o com quanto na sem debugging ! Muita informa\u00e7\u00e3o! Muitos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Exercise Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Exercise Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Mostre o valor inicial de global_var usando este comando e compare com o visto no arquivo parte2.c . Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos de C ( casting ) pode ser \u00fatil aqui. Exercise Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o , entenda como usar o comando x e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Em seguida, teste-o e garanta que funcionou corretamente. Link: https://sourceware.org/gdb/onlinedocs/gdb/Memory.html Dicas : volte nos exerc\u00edcios anteriores e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Exercise global_array tem tipo short . Ou seja, \u00e9 formado por dois bytes. Mostre agora o conte\u00fado de cada um deles. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Exercise Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"02 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/02-ram/#02-representacao-de-dados-em-ram","text":"","title":"02 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/02-ram/#experimentos","text":"Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles, execute e analise suas sa\u00eddas. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Tente entender o que est\u00e1 acontecendo. Para compilar cada .c , utilize: $ gcc -Wall -pedantic experimento0.c -o e0 Exercise Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa.","title":"Experimentos"},{"location":"aulas/02-ram/#representacao-de-struct-em-ram","text":"A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Aten\u00e7\u00e3o! Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Vamos compilar?! Compile e execute parte1.c . Exercise Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Exercise A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Exercise Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Hora de conferir! Agora confira suas respostas no arquivo parte1.c .","title":"Representa\u00e7\u00e3o de struct em RAM"},{"location":"aulas/02-ram/#examinando-a-execucao-de-programas-usando-gdb","text":"Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Dica! Para compilar um programa com suporte a debugging usamos a flag -g do gcc $ gcc -g -Wall -pedantic parte2.c -o parte2 Siga os passos para para carregar um programa usando o gdb : Lance o gdb e passe para ele seu programa: $ gdb ./parte2 Para sair, utilize: (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser acessada em: https://sourceware.org/gdb/onlinedocs/gdb/index.html#Top . Uma explica\u00e7\u00e3o detalhadas dos comandos do gdb pode ser encontrada nesse link: https://diveintosystems.org/book/C3-C_debug/gdb_commands.html . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Exercise Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Aten\u00e7\u00e3o, tarefa dupla! Para os pr\u00f3ximos exerc\u00edcios, compile o arquivo parte2.c com e sem debugging e repita cada exerc\u00edcio com ambas as vers\u00f5es do execut\u00e1vel. Exemplo de compila\u00e7\u00e3o: $ gcc -g -Wall -pedantic parte2.c -o parte2_debug $ gcc -Wall -pedantic parte2.c -o parte2_semdebug Exercise O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Execute-o e veja o que acontece. Exercise Use info para mostrar as fun\u00e7\u00f5es e vari\u00e1veis globais que existem em parte2 . Lembre de fazer tanto na vers\u00e3o com quanto na sem debugging ! Muita informa\u00e7\u00e3o! Muitos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Exercise Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Exercise Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Mostre o valor inicial de global_var usando este comando e compare com o visto no arquivo parte2.c . Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos de C ( casting ) pode ser \u00fatil aqui. Exercise Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o , entenda como usar o comando x e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Em seguida, teste-o e garanta que funcionou corretamente. Link: https://sourceware.org/gdb/onlinedocs/gdb/Memory.html Dicas : volte nos exerc\u00edcios anteriores e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Exercise global_array tem tipo short . Ou seja, \u00e9 formado por dois bytes. Mostre agora o conte\u00fado de cada um deles. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Exercise Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"Examinando a execu\u00e7\u00e3o de programas usando gdb"},{"location":"aulas/03-arquitetura-x86/","text":"03 - Arquitetura x86-64 \u00b6 No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o . Parando e continuando a execu\u00e7\u00e3o de um programa. \u00b6 Compile funcoes.c usando as flags: $ gcc -Og -g -Wall -std = c99 funcoes.c -o funcoes Tip Na compila\u00e7\u00e3o, -Og ir\u00e1 permitir otimiza\u00e7\u00f5es de c\u00f3digo que n\u00e3o interfiram no debugging. J\u00e1 o par\u00e2metro -g ir\u00e1 tornar dispon\u00edveis informa\u00e7\u00f5es \u00fateis para o debugging (como tipos de vari\u00e1veis e cabe\u00e7alhos das fun\u00e7\u00f5es) Exercise Abra o execut\u00e1vel com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Exercise O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Exercise Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Exercise Use o comando break funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Ap\u00f3s executar o run , utilize disas funcao1 e observe no c\u00f3digo da fun\u00e7\u00e3o uma seta indicando o pr\u00f3ximo comando a ser executado, que representa o breakpoint no in\u00edcio da fun\u00e7\u00e3o. Dica Os comandos info breakpoints , info b ou ainda i b podem ser utilizados para listar os breakpoints inseridos no c\u00f3digo! Exercise Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do Exerc\u00edcio 2 e escreva abaixo suas novas conclus\u00f5es. Exercise O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Dicas : se a primeira instru\u00e7\u00e3o for endbr64 , execute stepi mais uma vez! use disas de novo verifique novamente o conte\u00fado de %edi Exercise Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Exercise Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? Exercise Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Exercise Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado no endere\u00e7o descoberto no exerc\u00edcio anterior. Confira seu resultado com o c\u00f3digo. Tip Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine. Endere\u00e7amento relativo e vari\u00e1veis globais \u00b6 Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Exercise Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Exercise Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Exercise Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Exercise Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Exercise Anote abaixo o endere\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Desenho de acesso a mem\u00f3ria usando %rip A figura abaixo ilustra como funciona o endere\u00e7amento usando o registrador %rip . Note que os deslocamentos s\u00e3o diferentes pois o endere\u00e7o da instru\u00e7\u00e3o atual \u00e9 diferente. Por\u00e9m, o resultado final do endere\u00e7o calculado em ambas instru\u00e7\u00f5es \u00e9 o mesmo, indicando que ambas se referem ao mesmo local na mem\u00f3ria. Exercise Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Exercise Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Exercise Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf , analise as chamadas para responder o pr\u00f3ximo exerc\u00edcio! Exercise Encontre os endere\u00e7o das strings de formata\u00e7\u00e3o do printf e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo. Atividade para entrega! \u00b6 Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Dica Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar.","title":"03 - Arquitetura x86-64"},{"location":"aulas/03-arquitetura-x86/#03-arquitetura-x86-64","text":"No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o .","title":"03 - Arquitetura x86-64"},{"location":"aulas/03-arquitetura-x86/#parando-e-continuando-a-execucao-de-um-programa","text":"Compile funcoes.c usando as flags: $ gcc -Og -g -Wall -std = c99 funcoes.c -o funcoes Tip Na compila\u00e7\u00e3o, -Og ir\u00e1 permitir otimiza\u00e7\u00f5es de c\u00f3digo que n\u00e3o interfiram no debugging. J\u00e1 o par\u00e2metro -g ir\u00e1 tornar dispon\u00edveis informa\u00e7\u00f5es \u00fateis para o debugging (como tipos de vari\u00e1veis e cabe\u00e7alhos das fun\u00e7\u00f5es) Exercise Abra o execut\u00e1vel com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Exercise O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Exercise Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Exercise Use o comando break funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Ap\u00f3s executar o run , utilize disas funcao1 e observe no c\u00f3digo da fun\u00e7\u00e3o uma seta indicando o pr\u00f3ximo comando a ser executado, que representa o breakpoint no in\u00edcio da fun\u00e7\u00e3o. Dica Os comandos info breakpoints , info b ou ainda i b podem ser utilizados para listar os breakpoints inseridos no c\u00f3digo! Exercise Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do Exerc\u00edcio 2 e escreva abaixo suas novas conclus\u00f5es. Exercise O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Dicas : se a primeira instru\u00e7\u00e3o for endbr64 , execute stepi mais uma vez! use disas de novo verifique novamente o conte\u00fado de %edi Exercise Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Exercise Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? Exercise Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Exercise Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado no endere\u00e7o descoberto no exerc\u00edcio anterior. Confira seu resultado com o c\u00f3digo. Tip Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine.","title":"Parando e continuando a execu\u00e7\u00e3o de um programa."},{"location":"aulas/03-arquitetura-x86/#enderecamento-relativo-e-variaveis-globais","text":"Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Exercise Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Exercise Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Exercise Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Exercise Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Exercise Anote abaixo o endere\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Desenho de acesso a mem\u00f3ria usando %rip A figura abaixo ilustra como funciona o endere\u00e7amento usando o registrador %rip . Note que os deslocamentos s\u00e3o diferentes pois o endere\u00e7o da instru\u00e7\u00e3o atual \u00e9 diferente. Por\u00e9m, o resultado final do endere\u00e7o calculado em ambas instru\u00e7\u00f5es \u00e9 o mesmo, indicando que ambas se referem ao mesmo local na mem\u00f3ria. Exercise Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Exercise Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Exercise Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf , analise as chamadas para responder o pr\u00f3ximo exerc\u00edcio! Exercise Encontre os endere\u00e7o das strings de formata\u00e7\u00e3o do printf e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo.","title":"Endere\u00e7amento relativo e vari\u00e1veis globais"},{"location":"aulas/03-arquitetura-x86/#atividade-para-entrega","text":"Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Dica Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar.","title":"Atividade para entrega!"},{"location":"outros/DicasLinks/","text":"Dicas e links \u00b6 Refer\u00eancia para as instru\u00e7\u00f5es do Assembly x86 e amd64 \u00b6 Este guia de refer\u00eancia sobre as intru\u00e7\u00f5es da linguagem Assembly \u00e9 um resumo da refer\u00eancia oficial da Intel . Acredito que para nossos propositos na disciplina de SisHard seja suficiente. GDB - refer\u00eancia completa \u00b6 O GNU Debugger, mais conhecido por GDB, \u00e9 um depurador do GNU. Ele pode ser usado para depura\u00e7\u00e3o em sistemas Unix-like, como por exemplo o Ubuntu 22.04, na nossa disciplina usaremos o GDB para entender os c\u00f3digos em assemblye de atividades e do Lab01 Para aprender como depurar c\u00f3digo com GDB acesse este LINK e este LINK para conhecer os princiipais comandos. Acesse este LINK documenta\u00e7\u00e3o completa do GDB. Neste LINK tem as explica\u00e7\u00f5es do comando x ( x/nfu addr ) que permite examinar a mem\u00f3ria de um programa Assembly. Compiler Explorer - godbolt.org \u00b6 Compiler Explorer, tamb\u00e9m chamado de godbolt.org, \u00e9 um site interativo de explora\u00e7\u00e3o de compiladores. Ele permite ao usu\u00e1rio inserir c\u00f3digo em uma das linguagens C e visualizar a tradu\u00e7\u00e3o do c\u00f3digo para Assembly. Para utiliz\u00e1-lo acesse o LINK , a configua\u00e7\u00e3o do godbolt est\u00e1 nos slides da aula 04 - Fun\u00e7\u00f5es-mov . Resumo SisHard da Universidade Stanford \u00b6 No link abaixo est\u00e1 uma vis\u00e3o geral dos assuntos abordados na primeira parte da disciplina de Sistemas Hardware-Software elaborado na Universidade de Stanford. acesse o LINK Dicas ponteiros e aloca\u00e7\u00e3o de mem\u00f3ria na Linguagem C \u00b6 Alguns links que podem ajuda-los a entender ponteiros e aloca\u00e7\u00e3o de mem\u00f3ria na Linguagem C. Os links abaixo s\u00e3o do material desenvolvido pelo professor Paulo Feofiloff: Endere\u00e7os e ponteiros Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Os links abaixo s\u00e3o do material desenvolvido pelo professor Carlos Maziero: Ponteiros Aloca\u00e7\u00e3o de mem\u00f3ria Aloca\u00e7\u00e3o din\u00e2mica de matrizes","title":"Dicas e links"},{"location":"outros/DicasLinks/#dicas-e-links","text":"","title":"Dicas e links"},{"location":"outros/DicasLinks/#referencia-para-as-instrucoes-do-assembly-x86-e-amd64","text":"Este guia de refer\u00eancia sobre as intru\u00e7\u00f5es da linguagem Assembly \u00e9 um resumo da refer\u00eancia oficial da Intel . Acredito que para nossos propositos na disciplina de SisHard seja suficiente.","title":"Refer\u00eancia para as instru\u00e7\u00f5es do Assembly x86 e amd64"},{"location":"outros/DicasLinks/#gdb-referencia-completa","text":"O GNU Debugger, mais conhecido por GDB, \u00e9 um depurador do GNU. Ele pode ser usado para depura\u00e7\u00e3o em sistemas Unix-like, como por exemplo o Ubuntu 22.04, na nossa disciplina usaremos o GDB para entender os c\u00f3digos em assemblye de atividades e do Lab01 Para aprender como depurar c\u00f3digo com GDB acesse este LINK e este LINK para conhecer os princiipais comandos. Acesse este LINK documenta\u00e7\u00e3o completa do GDB. Neste LINK tem as explica\u00e7\u00f5es do comando x ( x/nfu addr ) que permite examinar a mem\u00f3ria de um programa Assembly.","title":"GDB - refer\u00eancia completa"},{"location":"outros/DicasLinks/#compiler-explorer-godboltorg","text":"Compiler Explorer, tamb\u00e9m chamado de godbolt.org, \u00e9 um site interativo de explora\u00e7\u00e3o de compiladores. Ele permite ao usu\u00e1rio inserir c\u00f3digo em uma das linguagens C e visualizar a tradu\u00e7\u00e3o do c\u00f3digo para Assembly. Para utiliz\u00e1-lo acesse o LINK , a configua\u00e7\u00e3o do godbolt est\u00e1 nos slides da aula 04 - Fun\u00e7\u00f5es-mov .","title":"Compiler Explorer - godbolt.org"},{"location":"outros/DicasLinks/#resumo-sishard-da-universidade-stanford","text":"No link abaixo est\u00e1 uma vis\u00e3o geral dos assuntos abordados na primeira parte da disciplina de Sistemas Hardware-Software elaborado na Universidade de Stanford. acesse o LINK","title":"Resumo SisHard da Universidade Stanford"},{"location":"outros/DicasLinks/#dicas-ponteiros-e-alocacao-de-memoria-na-linguagem-c","text":"Alguns links que podem ajuda-los a entender ponteiros e aloca\u00e7\u00e3o de mem\u00f3ria na Linguagem C. Os links abaixo s\u00e3o do material desenvolvido pelo professor Paulo Feofiloff: Endere\u00e7os e ponteiros Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Os links abaixo s\u00e3o do material desenvolvido pelo professor Carlos Maziero: Ponteiros Aloca\u00e7\u00e3o de mem\u00f3ria Aloca\u00e7\u00e3o din\u00e2mica de matrizes","title":"Dicas ponteiros e aloca\u00e7\u00e3o de mem\u00f3ria na Linguagem C"},{"location":"outros/github/","text":"Github Password \u00b6 Caso o seu Github esteja solicitando senha a cada push, voc\u00ea tem duas op\u00e7\u00f5es para configurar um esquema de login autom\u00e1tico: chave ssh ou token . Chave SSH \u00b6 Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando ssh , acesse este LINK e veja como criar uma chave no Ubuntu e adicionar no Github. Ap\u00f3s esta configura\u00e7\u00e3o, acessos utilizando esta chave ser\u00e3o automaticamente reconhecidos e aceitos como do seu usu\u00e1rio. Arquivo .netrc \u00b6 Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando https , acesse este LINK e crie um Token . Na cria\u00e7\u00e3o do Token, selecione uma validade adequada (pelo menos 90 dias) e marque em Select scopes pelo menos a se\u00e7\u00e3o repo . Em seguida, crie um arquivo .netrc (sim, come\u00e7a com \"ponto\") na raiz do seu usu\u00e1rio no Ubuntu. O conte\u00fado deste arquivo deve estar no padr\u00e3o: machine github.com login bruna2022 password ghp_123412341234123412341234123412341234 Example Substitua bruna2022 pelo seu usu\u00e1rio do Github e ghp_1234* pelo Token criado. No terminal, configure as permiss\u00f5es adequadas para o arquivo: $ chmod 600 ~/.netrc E feito! Clique aqui para mais informa\u00e7\u00f5es","title":"Github Password"},{"location":"outros/github/#github-password","text":"Caso o seu Github esteja solicitando senha a cada push, voc\u00ea tem duas op\u00e7\u00f5es para configurar um esquema de login autom\u00e1tico: chave ssh ou token .","title":"Github Password"},{"location":"outros/github/#chave-ssh","text":"Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando ssh , acesse este LINK e veja como criar uma chave no Ubuntu e adicionar no Github. Ap\u00f3s esta configura\u00e7\u00e3o, acessos utilizando esta chave ser\u00e3o automaticamente reconhecidos e aceitos como do seu usu\u00e1rio.","title":"Chave SSH"},{"location":"outros/github/#arquivo-netrc","text":"Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando https , acesse este LINK e crie um Token . Na cria\u00e7\u00e3o do Token, selecione uma validade adequada (pelo menos 90 dias) e marque em Select scopes pelo menos a se\u00e7\u00e3o repo . Em seguida, crie um arquivo .netrc (sim, come\u00e7a com \"ponto\") na raiz do seu usu\u00e1rio no Ubuntu. O conte\u00fado deste arquivo deve estar no padr\u00e3o: machine github.com login bruna2022 password ghp_123412341234123412341234123412341234 Example Substitua bruna2022 pelo seu usu\u00e1rio do Github e ghp_1234* pelo Token criado. No terminal, configure as permiss\u00f5es adequadas para o arquivo: $ chmod 600 ~/.netrc E feito! Clique aqui para mais informa\u00e7\u00f5es","title":"Arquivo .netrc"},{"location":"outros/vbox/","text":"Virtualbox \u00b6 Shared Folder \u00b6 Uma boa maneira de transferir arquivos entre a VM e a m\u00e1quina hospedeira (ambas as dire\u00e7\u00f5es) \u00e9 criar uma pasta compartilhada no Virtualbox. Acesse este LINK para mais informa\u00e7\u00f5es! Shared Clipboard \u00b6 Tamb\u00e9m \u00e9 poss\u00edvel fazer com que algo copiado (CTRL + C) no sistema principal possa ser colado no Ubuntu (CTRL + V na m\u00e1quina Virtual), e vice-versa! Procure no Google virtualbox enable shared clipboard .","title":"Virtualbox"},{"location":"outros/vbox/#virtualbox","text":"","title":"Virtualbox"},{"location":"outros/vbox/#shared-folder","text":"Uma boa maneira de transferir arquivos entre a VM e a m\u00e1quina hospedeira (ambas as dire\u00e7\u00f5es) \u00e9 criar uma pasta compartilhada no Virtualbox. Acesse este LINK para mais informa\u00e7\u00f5es!","title":"Shared Folder"},{"location":"outros/vbox/#shared-clipboard","text":"Tamb\u00e9m \u00e9 poss\u00edvel fazer com que algo copiado (CTRL + C) no sistema principal possa ser colado no Ubuntu (CTRL + V na m\u00e1quina Virtual), e vice-versa! Procure no Google virtualbox enable shared clipboard .","title":"Shared Clipboard"}]}